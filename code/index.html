<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Help on help</title>
  <script type="text/javascript" src="date.format.js"></script>
  <script type="text/javascript" src="client/settings.js"></script>
  <script type="text/javascript" src="client/auth.js"></script>
  <script type="text/javascript" src="client/channel.js"></script>
  <script type="text/javascript" src="client/listener.js"></script>
  <script type="text/javascript" src="client/processor.js"></script>
  <script type="text/javascript" src="client/textproc.js"></script>
  <script type="text/javascript">
	var chatSession = { id: 0, user: 0, name: '' };
	var channels = {};
	var active_chan = null;
	var server_host = '/sse-chat/server/';
	var msgHandlers = [];
	var default_title;
	var msg_counter = 0;
	var is_active = true;
	
	function presentLoginForm() {
		var form = document.getElementById('loginForm');
		form.elements['id'].value = Settings.user;
		form.elements['name'].value = Settings.name;
	}
	
	
	function authOk( response ) {
		if ( !response['session'] ) return;
		chatSession.id = response.session;
		chatSession.user = response.user;
		chatSession.name = response.username;
		Settings.user = chatSession.user;
		Settings.name = chatSession.name;
		
		//alert( chatSession.id );
		switchPanel( 'chat' );
		
		//if ( response['pin'] )
		//	showPin( response.pin );
		
		Settings.save();
		startListener();
	}
	function authErr( response ) {
		chatSession.id = 0;
		
		switchPanel( 'login' );
		showLoginError( response.message );
	}

	function encodeObject(data) {
		if(!data) return false;
		var pairs = [],
			regexp = /%20/g;

		for(var name in data) {
			var value = data[name].toString(),
			pair = encodeURIComponent(name).replace(regexp, '+') + '=' + encodeURIComponent(value).replace(regexp, '+');

			pairs.push(pair);
		}

		return pairs.join('&');
	}
	function convertFormToObject( form ) {
		var obj = {};
		for ( var i in form.elements ) {
			if ( form.elements[i]['name'] !== undefined && form.elements[i].name != '' )
				obj[ form.elements[i].name ] = form.elements[i].value;
		}
		return obj;
	}
	
	function switchPanel( panel ) {
		switch( panel ) {
			case 'chat':
				document.getElementById( 'chat' ).style.visibility = 'visible';
				document.getElementById( 'tabs' ).style.visibility = 'visible';
				document.getElementById( 'login' ).style.visibility = 'hidden';
				break;
			case 'login':
				document.getElementById( 'chat' ).style.visibility = 'hidden';
				document.getElementById( 'tabs' ).style.visibility = 'hidden';
				document.getElementById( 'login' ).style.visibility = 'visible';
				break;
			default:
				// TODO: tab processing
		}
	}
	
	function submitLogin( form ) {
		// test if name was changed, so that id will have to be reset
		/*if ( !form.is_guest ) {
			// member auth with login/password
			var auth = new AuthMember( 0, form.login );
			auth.ok = authOk;
			auth.err = authErr;
			auth.auth( server_host + 'auth', form.pin );
		} else */ {
			// preserve user ID for this computer
			if ( form.id != 0 && form.name != Settings.name )
				form.id = 0;
			var auth = new Auth( { id: form.id, name: form.name, isGuest: true } );
			auth.ok = authOk;
			auth.err = authErr;
			auth.auth( server_host + 'auth' );
		}
		
		return false;
	}
	
	function showLoginError( message ) {
		var msgNode = document.createTextNode( message );
		var errorNode = document.getElementById( 'loginError' );
		if ( errorNode.hasChildNodes() ) {
			errorNode.replaceChild( msgNode, errorNode.firstChild );
		} else {
			errorNode.appendChild( msgNode );
		}
	}
	
	function onSrvMessage( msg ) {
		switch( msg.event ) {
			case 'join':
				var ch = channels[ msg.channel ];
				if ( ch === undefined ) {
					ch = new Channel( msg.data );
					channels[ ch.id ] = ch;
				}
				ch.join( msg );
				updateChannelTabs();
				if ( active_chan == null ) {
					switchChannel( ch.id );
					var el = document.getElementById( 'tab-group' );
					if ( el && el.elements['tabs'] && el.elements.tabs.elements['channel'] ) {
						setTimeout( function(){ document.getElementById( 'tab-group' ).elements.tabs.elements[0].click(); }, 0 );
					}
				}
				break;
			case 'leave':
				var ch = channels[ msg.channel ];
				if ( ch !== undefined )
					ch.leave();
				break;
			case 'mychan':
				var ch = channels[ msg.data.channel.id ];
				if ( ch === undefined ) {
					ch = new Channel( msg.data.channel );
					channels[ ch.id ] = ch;
				} else {
					// update channel information
					ch.name = msg.data.channel.name;
					ch.title = msg.data.channel.title;
				}
				updateChannelTabs();
				if ( active_chan == null ) {
					switchChannel( ch.id );	
					var el = document.getElementById( 'tab-group' );
					if ( el && el.elements['tabs'] && el.elements.tabs.elements['channel'] ) {
						setTimeout( function(){ document.getElementById( 'tab-group' ).elements.tabs.elements[0].click(); }, 0 );
					}
				}
				break;
			default:
				console.log( 'Unknown service message: ' + JSON.stringify( msg ) );
		}
	}
	
	function onSysMessage( msg ) {
		var ch = channels[ msg.channel ];
		if ( ch === undefined ) return;
		
		switch( msg.command ) {
			case 'enter':
			case 'exit':
			case 'info':
				ch[ msg.command ]( msg );
				onNewMessage( ch );
				break;
			default:
				console.log( 'Unknown channel message: ' + JSON.stringify( msg ) );
		}
	}
	
	function onUserMessage( msg ) {
		var ch = channels[ msg.channel ];
		if ( ch === undefined ) return;
		
		ch.addMessage( msg );
		onNewMessage( ch );
	}
	
	function onNewMessage( channel ) {
		if ( active_chan == channel.id )
			setTimeout( function() { scrollToLastMessage(); }, 0 );
	}
	
	function scrollToLastMessage() {
		if ( active_chan !== undefined && channels[ active_chan ] !== undefined ) {
			//channels[ active_chan ].containerNode.lastChild.scrollIntoView();
			var objDiv = channels[ active_chan ].containerNode.lastChild;
			window.scrollTo( window.scrollX, objDiv.offsetTop );
		}
			
		offscreenMsgHandler();
	}
	
	function updateChannelTabs() {
		var tabsNode = document.getElementById( 'tabs' );
		var hasTabs = [];
		for ( var node = tabsNode.firstChild; node != null; node = node.nextSibling ) {
			// enlist all tabls
			if ( node.dataset && node.dataset.channelId )
				hasTabs.push( node.dataset.channelId );
		}
		if ( hasTabs.length == 0 && tabsNode.hasChildNodes() ) {
			// it seems that dataset is not supported, so just remove all nodes
			while ( tabsNode.hasChildNodes() )
				tabsNode.removeChild( tabsNode.lastChild );
		}
		
		for ( var i in channels ) {
			var ch = channels[ i ];
			var currentIdx = hasTabs.indexOf( ch.id );
			if ( currentIdx >= 0 ) {
				hasTabs.splice( currentIdx, 1 );
				continue;
			}
			
			var newTab = document.createElement( 'label' );
			newTab.dataset.channelId = ch.id;
			newTab.setAttribute( 'id', 'chantab_' + ch.id );
			// <input type="radio" name="channel">
			var opt = document.createElement( 'input' );
			opt.setAttribute( 'name', 'channel' );
			opt.setAttribute( 'type', 'radio' );
			opt.setAttribute( 'value', ch.id );
			newTab.appendChild( opt );
			var spanNode = document.createElement( 'span' );
			spanNode.appendChild( document.createTextNode( ch.name ) );
			newTab.appendChild( spanNode );
			
			opt.addEventListener( 'change', ( function _TabClickClosure(id){ 
				return function _TabClick(){ 
					switchChannel(id); 
					return false; 
				} }
			)( ch.id ) );
			
			tabsNode.appendChild( newTab );
		}
		
		// Remove all tabs that were not found in the updated list
		for ( var i in hasTabs ) {
			var el = document.getElementById( 'chantab_' + hasTabs[i] );
			if ( el && el.parentNode )
				el.parentNode.removeChild( el );
		}
		
		document.getElementById( 'msgs' ).style.top = tabsNode.offsetHeight + 'px';
	}
	
	function visibilityChange() {
		if ( !( document.hidden || !is_active ) ) {
			document.title = default_title;
			msg_counter = 0;
		} else {
			document.title = ' | ' + default_title;
		}
	}
	function onBlur() {
		is_active = false;
		visibilityChange();
	};
	function onFocus(){
		is_active = true;
		visibilityChange();
	};
	function offscreenMsgHandler() {
		if ( document.hidden || !is_active ) {
			++msg_counter;
			document.title = '(' + msg_counter + ')' + ' | ' + default_title;
		}
	}
	
	function startListener() {
		if ( 0 == chatSession.id ) return false;
		
		window.onfocus = onFocus;
		window.onblur = onBlur;
		document.addEventListener( 'visibilitychange', visibilityChange );
		
		var proc = new Processor();
		proc.userMsg = onUserMessage;
		proc.sysMsg = onSysMessage;
		proc.serviceMsg = onSrvMessage;
		
		// Only start listener after we authorized
		var listener = new Listener( proc );
		listener.listen( server_host + 'session?id=' + chatSession.id );
	}
	
	function switchChannel( id ) {
		var el = document.getElementById( 'msgs' );
		var ch = channels[ id ];
		if ( ch === undefined ) 
			return;
		active_chan = id;
		
		if ( el.hasChildNodes() )
			el.removeChild( el.firstChild );
		el.appendChild( ch.containerNode );
	}
	
	function sendTextMessage() {
		if ( !active_chan ) return false;
		var msg_el = document.getElementById( 'message' );
		if ( !msg_el ) return false;
		var message = (new String( msg_el.value)).trim();
		if ( !message ) return false;
		
		var msg_object = { id: chatSession.id, chan: channels[active_chan].id, msg: message };
		post( 'message/', msg_object ); 
		
		document.getElementById( 'message' ).value = '';
		return false;
	};	
	
    function onDomReady() {
		default_title = document.title;
		Settings.load();
			//auth();
		presentLoginForm();
		
		document.getElementById('message').onkeypress = function _SendMsg(event) {
				// send with "Enter", newline with "Shift+Enter"
				if ( event.keyCode == 10 || ( event.keyCode == 13 && !event.ctrlKey && !event.shiftKey ) ) { 
					return sendTextMessage();
				}
				return true;
			};
	}

    window.onload = onDomReady;

    function post( url, msg_object ) {
		var xhr = new XMLHttpRequest();
		xhr.open( 'POST', server_host + url, true );
		xhr.setRequestHeader( 'Content-type', 'application/x-www-form-urlencoded' );
		xhr.onreadystatechange = function () {
			if ( xhr.readyState === 4 ) {				
				console.info( xhr.statusText + ' ' + xhr.responseText );
			}
		};
		// Message text is sent in POST body
		xhr.send( encodeObject( msg_object ) );
    }
	
  </script>
  <style type="text/css">
	html * { font-family: Trebuchet MS; font-size: 12pt }
	fieldset { border: none; padding: 0em; margin: 0em }
	
	#tabs { list-style-type: none; position: fixed; top: 0em; left: 0em; width: 100%; background: white; z-index: 5 }
	#tabs input[type="radio"] { display: none }
	#tabs input[type="radio"]:checked + * { font-weight: bold }	
	#tabs label { display: inline-block; border: 1px solid silver; padding: 0em 1em }
	#msgs {
		padding: 0em 0em 8em;
		position: relative;
	}
    #msgs > section {
		display: block;
		/* position: relative; */
    }
	#msgs section {}
	#msgs aside { font-style: italic }
	#msgs .timestamp { float: right; width: 6em }
	#msgs .author { width: 8em; text-align: right; float: left; margin-right: -8em }
	#msgs .text { margin: 0em 9em }
	#msgs .text p { margin: 0em }
	#msgs .text p+p { margin-top: 0.5em }
	#chat { position: relative; visibility: hidden; }
	#input-table { position: fixed; left: 0px; bottom: 0px; width: 100%; height: 7em; z-index: 4; background: white }
	#input-table td:first-child { width: 9em }
	#input-table td:last-child { width: 6em }
	#login { position: absolute; display: table; left: 1em; top: 1em }
	#login form { display: table-row }
	#loginError:empty { display: none }
		
	#message { width: 100%; height: 6em }
	
	#login fieldset { margin-top: 1em }
	#login #guestchk { display: none }
	#login #guestchk:not(:checked) ~ .guest, #guestchk:checked ~ .registered { display: none }
	
	#login #guestchk ~ label { background: white; border-bottom: 1px dashed; cursor: pointer  }
	#login #guestchk ~ label + label { margin-left: 0.5em; }
	#login #guestchk:checked ~ label#lbl-guest, #login #guestchk:not(:checked) ~ label#lbl-registered { font-weight: bold; border-bottom: none }
		
	.self { color: gray; }
	.other { color: black; }
	.system { color: black; font-style: italic }
	
	.author { font-weight: bold; margin-right: 1em; width: 10em }
	.author.self { color: blue; }
	.author.other { color: black; }
	
	.timestamp { color: gray;}
  </style>
</head>
<body>
	<form id="tab-group"><fieldset id="tabs"></fieldset></form>
	<div id="chat">
		<div id="msgs"></div>
		<table id="input-table"><tr>
		<td>Controls</td>
		<td><textarea id="message"></textarea></td>
		<td><button type="button" onclick="sendTextMessage();">Send</button></td>
		
		</tr></table>
	</div>
	<div id="login">
		<form action="?" onsubmit="return submitLogin(convertFormToObject(this));" id="loginForm">
			<input type="checkbox" id="guestchk" name="is_guest" checked/>
			<label for="guestchk" id="lbl-registered">Участник</label>
			<label for="guestchk" id="lbl-guest">Гость</label>
		<fieldset class="registered">
			<!-- label>Логин: <input type="text" name="login" id="login" /></label>
			<label>Пин: <input type="text" name="pin" id="pin" size="5" maxlength="4" value=""/></label>
			<input type="hidden" name="id" value="0" />
			<input type="submit" value="Ок" / -->
			<p>Регистрация пользователей ещё не готова. Побудьте пока дорогим гостем :)
		</fieldset><fieldset class="guest">
			<label>Ваше имя: <input type="text" name="name" id="name" /></label>
			<input type="hidden" name="id" value="0" />
			<input type="submit" value="Ок" />		
		</fieldset>
			<p id="loginError"></p>
		</form>	
		
	</div>
	
</body>
</html>